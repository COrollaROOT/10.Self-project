namespace Team_Project_10
{
    /*
        알고리즘 기본실습 내용을 팀으로 같이 인터넷 서칭을 통해서,
        정보 검색을 통해서 게임에 유용하게 사용할 수 있는 알고리즘들을 조사
        팀원들과 공유
    */

    internal class Program
    {
        static void Main(string[] args)
        {
            
        }
    }
}

/* 버블 정렬 : 인접한 두 원소를 비교하여 순서가 잘못되어 있다면 서로 교환하는 과정을 반복하여 정렬을 수행

 삽입 정렬 : 리스트를 정렬된 부분과 정렬되지 않은 부분으로 나눈 후,
              정렬되지 않은 부분의 원소를 정렬된 부분의 적절한 위치에 삽입하는 과정을 반복하여 정렬

 선택 정렬 : 주어진 리스트에서 최소값을 선택하여 정렬되지 않은 부분과 정렬된 부분을 나누고,
              정렬되지 않은 부분에서 최소값을 선택하여 정렬된 부분에 추가하는 과정을 반복

 퀵 정렬 : 분할 정복(Divide and Conquer) 기법을 사용하는 정렬 알고리즘으로,리스트를 기준값을 중심으로 분할한 후 재귀적으로 정렬

 병합 정렬 : 분할 정복(Divide and Conquer) 기법을 사용하는 정렬 알고리즘으로,
                리스트를 반으로 나눈 후 재귀적으로 정렬한 다음, 정렬된 부분 리스트를 병합하여 최종적으로 정렬
 힙 정렬 : 힙(Heap) 자료구조를 이용하여 정렬을 수행하는 알고리즘으로,
            주어진 리스트를 최대 힙(Max Heap) 또는 최소 힙(Min Heap)으로 구성한 후,
            힙에서 원소를 하나씩 꺼내 정렬된 순서로 배열

 기타( 계수 정렬, 셸 정렬, 거품 정렬, 래딕스 정렬)

 탐색 정렬
 DFS : 깊이 우선 탐색
        트리나 그래프에서 한 루트로 탐색하다가 특정 상황에서 최대한 깊숙이 들어가서 확인한 뒤 다시 돌아가 다른 루트로 탐색하는 방식
        백트래킹에 사용 재귀호출을 사용하여 구현하지만, 단순한 스택 배열로 구현하기도 한다. 구조상 스택 오버플로우를 유의
 
BFS : 너비 우선 탐색
        여러 갈래 중 무한한 길이를 가지는 경로가 존재하고 탐색 목표가 다른 경로에 존재하는 경우
        DFS로 탐색할 시에는 무한한 길이의 경로에서 영원히 종료하지 못하지만
        BFS의 경우는 모든 경로를 동시에 진행하기 때문에 탐색이 가능하다는 특징

 길 찾기 알고리즘
    길찾기 알고리즘 또한, 알고리즘 주제가 나왔을 시, 빠지지 않고 등장하는 요소입니다.
    주어진 출발지와 목적지가 주어지면, 해당 목적지까지 어떻게 갈 지를 해결하는 것으로,
    길찾기 알고리즘은 게임에서 몬스터의 플레이어 추적,플레이어 자동 이동
    일상 생활에선 네비게이션이나 배달 어플리케이션에서도 사용되는 등 상당히 유용

 다익스트라 알고리즘 : 단일 출발지에서 모든 노드까지의 최단 경로를 찾는 알고리즘 */